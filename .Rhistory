factor = .001
this_N = N * factor
this_D = rpois(length(this_N), this_N * D/N)
##==================
## first exploratory iterations
alpha = rep(0,K)
D1 = diff( diag(K), diff=1) # first differencing matrix
P  = 2 * crossprod(D1)    # roughness penalty is alpha' [P] alpha
next_alpha = function(alpha) {
mu1 = as.vector( exp( std + B %*% alpha))   # single-year rates
mu  = as.vector( W %*% mu1)                 # age group avg rates
BMW  = t(B) %*% diag(mu1) %*% t(W) %*% diag(1/mu)
Dhat = this_N * mu
# score (gradient of penalized likelihood wrt TOPALS alphas)
S = ( BMW %*% (this_D - Dhat) ) - P %*% alpha
# expected value of Hessian at current alpha values
H = +( BMW %*% diag(this_N*mu) %*% t(BMW) + tcrossprod(P %*% alpha) )
update = solve(H) %*% S
## try several step sizes
step_size = 2^(-(0:5))
trial_Q   = NA*step_size
for (i in seq(step_size)) {
trial_Q[i] = Qval( alpha + step_size[i] * update)
}
ibest = which.min(trial_Q)
best_update = update * step_size[ibest]
new_value = alpha + best_update
print(list(stepsize=step_size[ibest],
params = data.frame(alpha, best_update, new_value),
Qval   = data.frame(Q.old=Q(alpha), Q.new=Q(new_value))))
return(new_value)
}
maxiter = 200
a = matrix(NA, K, maxiter)
a[,1] = alpha
i = 2
while (i <= maxiter) {
a[,i] = next_alpha( a[,i-1])
delta_a = a[,i] - a[,i-1]
if (all(abs(delta_a) < .00005)) break
i = i+1
}
if (i>maxiter) {
print('--- DID NOT CONVERGE ---')
alpha_hat = a[,maxiter]
} else {
alpha_hat = a[,i]
}
## plot data
hues = c('red','darkgreen','royalblue','orangered','salmon','lawngreen')
plot(  age+.50, rate1$logmx[1:100], pch=16, ylim=c(-10,0),
main=paste(sum(this_D),'deaths among', round(sum(this_N)),'women'),
sub = ifelse(i>maxiter,'DID NOT CONVERGE','CONVERGED'))
lines( age+.50, std, col='grey', lwd=3)
this_color = sample(hues,1)
lines( age+.50, std + B %*% alpha_hat, col=this_color, lwd=5)
for (i in seq(L)) {
y = log(this_D[i]/this_N[i])
H = ifelse(i<length(L), L[i+1], 100)
segments(L[i],y,H,y, col=this_color, lwd=4)
}
abline(v=c(L,100),lty=2, col='grey')
text(L, -9, this_D, cex=.80)
points( knot_positions, rep(-10,length(knot_positions)), pch=15, col=2,cex=1.2)
factor = .001
this_N = N * factor
this_D = rpois(length(this_N), this_N * D/N)
##==================
## first exploratory iterations
alpha = rep(0,K)
D1 = diff( diag(K), diff=1) # first differencing matrix
P  = 2 * crossprod(D1)    # roughness penalty is alpha' [P] alpha
next_alpha = function(alpha) {
mu1 = as.vector( exp( std + B %*% alpha))   # single-year rates
mu  = as.vector( W %*% mu1)                 # age group avg rates
BMW  = t(B) %*% diag(mu1) %*% t(W) %*% diag(1/mu)
Dhat = this_N * mu
# score (gradient of penalized likelihood wrt TOPALS alphas)
S = ( BMW %*% (this_D - Dhat) ) - P %*% alpha
# expected value of Hessian at current alpha values
H = +( BMW %*% diag(this_N*mu) %*% t(BMW) + tcrossprod(P %*% alpha) )
update = solve(H) %*% S
## try several step sizes
step_size = 2^(-(0:5))
trial_Q   = NA*step_size
for (i in seq(step_size)) {
trial_Q[i] = Qval( alpha + step_size[i] * update)
}
ibest = which.min(trial_Q)
best_update = update * step_size[ibest]
new_value = alpha + best_update
print(list(stepsize=step_size[ibest],
params = data.frame(alpha, best_update, new_value),
Qval   = data.frame(Q.old=Q(alpha), Q.new=Q(new_value))))
return(new_value)
}
maxiter = 200
a = matrix(NA, K, maxiter)
a[,1] = alpha
i = 2
while (i <= maxiter) {
a[,i] = next_alpha( a[,i-1])
delta_a = a[,i] - a[,i-1]
if (all(abs(delta_a) < .00005)) break
i = i+1
}
if (i>maxiter) {
print('--- DID NOT CONVERGE ---')
alpha_hat = a[,maxiter]
} else {
alpha_hat = a[,i]
}
## plot data
hues = c('red','darkgreen','royalblue','orangered','salmon','lawngreen')
plot(  age+.50, rate1$logmx[1:100], pch=16, ylim=c(-10,0),
main=paste(sum(this_D),'deaths among', round(sum(this_N)),'women'),
sub = ifelse(i>maxiter,'DID NOT CONVERGE','CONVERGED'))
lines( age+.50, std, col='grey', lwd=3)
this_color = sample(hues,1)
lines( age+.50, std + B %*% alpha_hat, col=this_color, lwd=5)
for (i in seq(L)) {
y = log(this_D[i]/this_N[i])
H = ifelse(i<length(L), L[i+1], 100)
segments(L[i],y,H,y, col=this_color, lwd=4)
}
abline(v=c(L,100),lty=2, col='grey')
text(L, -9, this_D, cex=.80)
points( knot_positions, rep(-10,length(knot_positions)), pch=15, col=2,cex=1.2)
factor = 1
this_N = N * factor
this_D = rpois(length(this_N), this_N * D/N)
##==================
## first exploratory iterations
alpha = rep(0,K)
D1 = diff( diag(K), diff=1) # first differencing matrix
P  = 2 * crossprod(D1)    # roughness penalty is alpha' [P] alpha
next_alpha = function(alpha) {
mu1 = as.vector( exp( std + B %*% alpha))   # single-year rates
mu  = as.vector( W %*% mu1)                 # age group avg rates
BMW  = t(B) %*% diag(mu1) %*% t(W) %*% diag(1/mu)
Dhat = this_N * mu
# score (gradient of penalized likelihood wrt TOPALS alphas)
S = ( BMW %*% (this_D - Dhat) ) - P %*% alpha
# expected value of Hessian at current alpha values
H = +( BMW %*% diag(this_N*mu) %*% t(BMW) + tcrossprod(P %*% alpha) )
update = solve(H) %*% S
## try several step sizes
step_size = 2^(-(0:5))
trial_Q   = NA*step_size
for (i in seq(step_size)) {
trial_Q[i] = Qval( alpha + step_size[i] * update)
}
ibest = which.min(trial_Q)
best_update = update * step_size[ibest]
new_value = alpha + best_update
print(list(stepsize=step_size[ibest],
params = data.frame(alpha, best_update, new_value),
Qval   = data.frame(Q.old=Q(alpha), Q.new=Q(new_value))))
return(new_value)
}
maxiter = 200
a = matrix(NA, K, maxiter)
a[,1] = alpha
i = 2
while (i <= maxiter) {
a[,i] = next_alpha( a[,i-1])
delta_a = a[,i] - a[,i-1]
if (all(abs(delta_a) < .00005)) break
i = i+1
}
if (i>maxiter) {
print('--- DID NOT CONVERGE ---')
alpha_hat = a[,maxiter]
} else {
alpha_hat = a[,i]
}
## plot data
hues = c('red','darkgreen','royalblue','orangered','salmon','lawngreen')
plot(  age+.50, rate1$logmx[1:100], pch=16, ylim=c(-10,0),
main=paste(sum(this_D),'deaths among', round(sum(this_N)),'women'),
sub = ifelse(i>maxiter,'DID NOT CONVERGE','CONVERGED'))
lines( age+.50, std, col='grey', lwd=3)
this_color = sample(hues,1)
lines( age+.50, std + B %*% alpha_hat, col=this_color, lwd=5)
for (i in seq(L)) {
y = log(this_D[i]/this_N[i])
H = ifelse(i<length(L), L[i+1], 100)
segments(L[i],y,H,y, col=this_color, lwd=4)
}
abline(v=c(L,100),lty=2, col='grey')
text(L, -9, this_D, cex=.80)
points( knot_positions, rep(-10,length(knot_positions)), pch=15, col=2,cex=1.2)
factor = 1
this_N = N * factor
this_D = rpois(length(this_N), this_N * D/N)
##==================
## first exploratory iterations
alpha = rep(0,K)
D1 = diff( diag(K), diff=1) # first differencing matrix
P  = 2 * crossprod(D1)    # roughness penalty is alpha' [P] alpha
next_alpha = function(alpha) {
mu1 = as.vector( exp( std + B %*% alpha))   # single-year rates
mu  = as.vector( W %*% mu1)                 # age group avg rates
BMW  = t(B) %*% diag(mu1) %*% t(W) %*% diag(1/mu)
Dhat = this_N * mu
# score (gradient of penalized likelihood wrt TOPALS alphas)
S = ( BMW %*% (this_D - Dhat) ) - P %*% alpha
# expected value of Hessian at current alpha values
H = +( BMW %*% diag(this_N*mu) %*% t(BMW) + tcrossprod(P %*% alpha) )
update = solve(H) %*% S
## try several step sizes
step_size = 2^(-(0:4))
trial_Q   = NA*step_size
for (i in seq(step_size)) {
trial_Q[i] = Qval( alpha + step_size[i] * update)
}
ibest = which.min(trial_Q)
best_update = update * step_size[ibest]
new_value = alpha + best_update
print(list(stepsize=step_size[ibest],
params = data.frame(alpha, best_update, new_value),
Qval   = data.frame(Q.old=Q(alpha), Q.new=Q(new_value))))
return(new_value)
}
maxiter = 200
a = matrix(NA, K, maxiter)
a[,1] = alpha
i = 2
while (i <= maxiter) {
a[,i] = next_alpha( a[,i-1])
delta_a = a[,i] - a[,i-1]
if (all(abs(delta_a) < .00005)) break
i = i+1
}
if (i>maxiter) {
print('--- DID NOT CONVERGE ---')
alpha_hat = a[,maxiter]
} else {
alpha_hat = a[,i]
}
## plot data
hues = c('red','darkgreen','royalblue','orangered','salmon','lawngreen')
plot(  age+.50, rate1$logmx[1:100], pch=16, ylim=c(-10,0),
main=paste(sum(this_D),'deaths among', round(sum(this_N)),'women'),
sub = ifelse(i>maxiter,'DID NOT CONVERGE','CONVERGED'))
lines( age+.50, std, col='grey', lwd=3)
this_color = sample(hues,1)
lines( age+.50, std + B %*% alpha_hat, col=this_color, lwd=5)
for (i in seq(L)) {
y = log(this_D[i]/this_N[i])
H = ifelse(i<length(L), L[i+1], 100)
segments(L[i],y,H,y, col=this_color, lwd=4)
}
abline(v=c(L,100),lty=2, col='grey')
text(L, -9, this_D, cex=.80)
points( knot_positions, rep(-10,length(knot_positions)), pch=15, col=2,cex=1.2)
factor = 1
this_N = N * factor
this_D = rpois(length(this_N), this_N * D/N)
##==================
## first exploratory iterations
alpha = rep(0,K)
D1 = diff( diag(K), diff=1) # first differencing matrix
P  = 2 * crossprod(D1)    # roughness penalty is alpha' [P] alpha
next_alpha = function(alpha) {
mu1 = as.vector( exp( std + B %*% alpha))   # single-year rates
mu  = as.vector( W %*% mu1)                 # age group avg rates
BMW  = t(B) %*% diag(mu1) %*% t(W) %*% diag(1/mu)
Dhat = this_N * mu
# score (gradient of penalized likelihood wrt TOPALS alphas)
S = ( BMW %*% (this_D - Dhat) ) - P %*% alpha
# expected value of Hessian at current alpha values
H = +( BMW %*% diag(this_N*mu) %*% t(BMW) + tcrossprod(P %*% alpha) )
update = solve(H) %*% S
## try several step sizes
step_size = 2^(-(0:4))
trial_Q   = NA*step_size
for (i in seq(step_size)) {
trial_Q[i] = Qval( alpha + step_size[i] * update)
}
ibest = which.min(trial_Q)
best_update = update * step_size[ibest]
new_value = alpha + best_update
print(list(stepsize=step_size[ibest],
params = data.frame(alpha, best_update, new_value),
Qval   = data.frame(Q.old=Q(alpha), Q.new=Q(new_value))))
return(new_value)
}
maxiter = 200
a = matrix(NA, K, maxiter)
a[,1] = alpha
i = 2
while (i <= maxiter) {
a[,i] = next_alpha( a[,i-1])
delta_a = a[,i] - a[,i-1]
if (all(abs(delta_a) < .00005)) break
i = i+1
}
if (i>maxiter) {
print('--- DID NOT CONVERGE ---')
alpha_hat = a[,maxiter]
} else {
alpha_hat = a[,i]
}
## plot data
hues = c('red','darkgreen','royalblue','orangered','salmon','lawngreen')
plot(  age+.50, rate1$logmx[1:100], pch=16, ylim=c(-10,0),
main=paste(sum(this_D),'deaths among', round(sum(this_N)),'women'),
sub = ifelse(i>maxiter,'DID NOT CONVERGE','CONVERGED'))
lines( age+.50, std, col='grey', lwd=3)
this_color = sample(hues,1)
lines( age+.50, std + B %*% alpha_hat, col=this_color, lwd=5)
for (i in seq(L)) {
y = log(this_D[i]/this_N[i])
H = ifelse(i<length(L), L[i+1], 100)
segments(L[i],y,H,y, col=this_color, lwd=4)
}
abline(v=c(L,100),lty=2, col='grey')
text(L, -9, this_D, cex=.80)
points( knot_positions, rep(-10,length(knot_positions)), pch=15, col=2,cex=1.2)
factor = 1
this_N = N * factor
this_D = rpois(length(this_N), this_N * D/N)
##==================
## first exploratory iterations
alpha = rep(0,K)
D1 = diff( diag(K), diff=1) # first differencing matrix
P  = 2 * crossprod(D1)    # roughness penalty is alpha' [P] alpha
next_alpha = function(alpha) {
mu1 = as.vector( exp( std + B %*% alpha))   # single-year rates
mu  = as.vector( W %*% mu1)                 # age group avg rates
BMW  = t(B) %*% diag(mu1) %*% t(W) %*% diag(1/mu)
Dhat = this_N * mu
# score (gradient of penalized likelihood wrt TOPALS alphas)
S = ( BMW %*% (this_D - Dhat) ) - P %*% alpha
# expected value of Hessian at current alpha values
H = +( BMW %*% diag(this_N*mu) %*% t(BMW) + tcrossprod(P %*% alpha) )
update = solve(H) %*% S
## try several step sizes
step_size = 2^(-(0:4))
trial_Q   = NA*step_size
for (i in seq(step_size)) {
trial_Q[i] = Qval( alpha + step_size[i] * update)
}
ibest = which.min(trial_Q)
best_update = update * step_size[ibest]
new_value = alpha + best_update
print(list(stepsize=step_size[ibest],
params = data.frame(alpha, best_update, new_value),
Qval   = data.frame(Q.old=Q(alpha), Q.new=Q(new_value))))
return(new_value)
}
maxiter = 200
a = matrix(NA, K, maxiter)
a[,1] = alpha
i = 2
while (i <= maxiter) {
a[,i] = next_alpha( a[,i-1])
delta_a = a[,i] - a[,i-1]
if (all(abs(delta_a) < .00005)) break
i = i+1
}
if (i>maxiter) {
print('--- DID NOT CONVERGE ---')
alpha_hat = a[,maxiter]
} else {
alpha_hat = a[,i]
}
## plot data
hues = c('red','darkgreen','royalblue','orangered','salmon','lawngreen')
plot(  age+.50, rate1$logmx[1:100], pch=16, ylim=c(-10,0),
main=paste(sum(this_D),'deaths among', round(sum(this_N)),'women'),
sub = ifelse(i>maxiter,'DID NOT CONVERGE','CONVERGED'))
lines( age+.50, std, col='grey', lwd=3)
this_color = sample(hues,1)
lines( age+.50, std + B %*% alpha_hat, col=this_color, lwd=5)
for (i in seq(L)) {
y = log(this_D[i]/this_N[i])
H = ifelse(i<length(L), L[i+1], 100)
segments(L[i],y,H,y, col=this_color, lwd=4)
}
abline(v=c(L,100),lty=2, col='grey')
text(L, -9, this_D, cex=.80)
points( knot_positions, rep(-10,length(knot_positions)), pch=15, col=2,cex=1.2)
factor = 1
this_N = N * factor
this_D = rpois(length(this_N), this_N * D/N)
##==================
## first exploratory iterations
alpha = rep(0,K)
D1 = diff( diag(K), diff=1) # first differencing matrix
P  = 2 * crossprod(D1)    # roughness penalty is alpha' [P] alpha
next_alpha = function(alpha) {
mu1 = as.vector( exp( std + B %*% alpha))   # single-year rates
mu  = as.vector( W %*% mu1)                 # age group avg rates
BMW  = t(B) %*% diag(mu1) %*% t(W) %*% diag(1/mu)
Dhat = this_N * mu
# score (gradient of penalized likelihood wrt TOPALS alphas)
S = ( BMW %*% (this_D - Dhat) ) - P %*% alpha
# expected value of Hessian at current alpha values
H = +( BMW %*% diag(this_N*mu) %*% t(BMW) + tcrossprod(P %*% alpha) )
update = solve(H) %*% S
## try several step sizes
step_size = 2^(-(0:4))
trial_Q   = NA*step_size
for (i in seq(step_size)) {
trial_Q[i] = Qval( alpha + step_size[i] * update)
}
ibest = which.min(trial_Q)
best_update = update * step_size[ibest]
new_value = alpha + best_update
print(list(stepsize=step_size[ibest],
params = data.frame(alpha, best_update, new_value),
Qval   = data.frame(Q.old=Q(alpha), Q.new=Q(new_value))))
return(new_value)
}
maxiter = 200
a = matrix(NA, K, maxiter)
a[,1] = alpha
i = 2
while (i <= maxiter) {
a[,i] = next_alpha( a[,i-1])
delta_a = a[,i] - a[,i-1]
if (all(abs(delta_a) < .00005)) break
i = i+1
}
if (i>maxiter) {
print('--- DID NOT CONVERGE ---')
alpha_hat = a[,maxiter]
} else {
alpha_hat = a[,i]
}
## plot data
hues = c('red','darkgreen','royalblue','orangered','salmon','lawngreen')
plot(  age+.50, rate1$logmx[1:100], pch=16, ylim=c(-10,0),
main=paste(sum(this_D),'deaths among', round(sum(this_N)),'women'),
sub = ifelse(i>maxiter,'DID NOT CONVERGE','CONVERGED'))
lines( age+.50, std, col='grey', lwd=3)
this_color = sample(hues,1)
lines( age+.50, std + B %*% alpha_hat, col=this_color, lwd=5)
for (i in seq(L)) {
y = log(this_D[i]/this_N[i])
H = ifelse(i<length(L), L[i+1], 100)
segments(L[i],y,H,y, col=this_color, lwd=4)
}
abline(v=c(L,100),lty=2, col='grey')
text(L, -9, this_D, cex=.80)
points( knot_positions, rep(-10,length(knot_positions)), pch=15, col=2,cex=1.2)
factor = 1
this_N = N * factor
this_D = rpois(length(this_N), this_N * D/N)
##==================
## first exploratory iterations
alpha = rep(0,K)
D1 = diff( diag(K), diff=1) # first differencing matrix
P  = 2 * crossprod(D1)    # roughness penalty is alpha' [P] alpha
next_alpha = function(alpha) {
mu1 = as.vector( exp( std + B %*% alpha))   # single-year rates
mu  = as.vector( W %*% mu1)                 # age group avg rates
BMW  = t(B) %*% diag(mu1) %*% t(W) %*% diag(1/mu)
Dhat = this_N * mu
# score (gradient of penalized likelihood wrt TOPALS alphas)
S = ( BMW %*% (this_D - Dhat) ) - P %*% alpha
# expected value of Hessian at current alpha values
H = +( BMW %*% diag(this_N*mu) %*% t(BMW) + tcrossprod(P %*% alpha) )
update = solve(H) %*% S
## try several step sizes
step_size = 2^(-(0:4))
trial_Q   = NA*step_size
for (i in seq(step_size)) {
trial_Q[i] = Qval( alpha + step_size[i] * update)
}
ibest = which.min(trial_Q)
best_update = update * step_size[ibest]
new_value = alpha + best_update
print(list(stepsize=step_size[ibest],
params = data.frame(alpha, best_update, new_value),
Qval   = data.frame(Q.old=Q(alpha), Q.new=Q(new_value))))
return(new_value)
}
maxiter = 200
a = matrix(NA, K, maxiter)
a[,1] = alpha
i = 2
while (i <= maxiter) {
a[,i] = next_alpha( a[,i-1])
delta_a = a[,i] - a[,i-1]
if (all(abs(delta_a) < .00005)) break
i = i+1
}
if (i>maxiter) {
print('--- DID NOT CONVERGE ---')
alpha_hat = a[,maxiter]
} else {
alpha_hat = a[,i]
}
## plot data
hues = c('red','darkgreen','royalblue','orangered','salmon','lawngreen')
plot(  age+.50, rate1$logmx[1:100], pch=16, ylim=c(-10,0),
main=paste(sum(this_D),'deaths among', round(sum(this_N)),'women'),
sub = ifelse(i>maxiter,'DID NOT CONVERGE','CONVERGED'))
lines( age+.50, std, col='grey', lwd=3)
this_color = sample(hues,1)
lines( age+.50, std + B %*% alpha_hat, col=this_color, lwd=5)
for (i in seq(L)) {
y = log(this_D[i]/this_N[i])
H = ifelse(i<length(L), L[i+1], 100)
segments(L[i],y,H,y, col=this_color, lwd=4)
}
abline(v=c(L,100),lty=2, col='grey')
text(L, -9, this_D, cex=.80)
points( knot_positions, rep(-10,length(knot_positions)), pch=15, col=2,cex=1.2)
