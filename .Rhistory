nalpha = ncol(B)
## penalized log lik function
Q = function(alpha) {
lambda.hat = as.numeric( std + B %*% alpha)
penalty = smoothing_k * sum(diff(alpha)^2)
return( sum(D * lambda.hat - N * exp(lambda.hat)) - penalty)
}
## expected deaths function
Dhat = function(alpha) {
lambda.hat = std + B %*% alpha
return(  as.numeric( N * exp(lambda.hat) ))
}
## S matrix for penalty
S = matrix(0,nalpha-1,nalpha)
diag(S[, 1:(nalpha-1)]) = -1
diag(S[, 2:(nalpha)  ]) = +1
SS = crossprod(S)
#------------------------------------------------
# iteration function:
# next alpha vector as a function of current alpha
#------------------------------------------------
next_alpha = function(alpha) {
dhat = Dhat(alpha)
M = solve ( t(B) %*% diag(dhat) %*% B + 2*smoothing_k*SS)
v = t(B) %*% (D - dhat) - 2* (smoothing_k * SS %*% alpha)
return( alpha + M %*% v)
}
## main iteration:
a = rep(0, nalpha)
niter = 0
repeat {
niter      = niter + 1
last_param = a
a          = next_alpha( a )  # update
change     = a - last_param
converge = all( abs(change) < alpha_tol)
overrun  = (niter == max_iter)
if (converge | overrun) { break }
} # repeat
return( list( alpha = a, converge=converge, maxiter = overrun))
} # TOPALS_fit
#=====================================================
# EXAMPLE: SMALL POPULATIONS WITH RANDOM DEATHS
#=====================================================
N = c(62, 62, 50, 65, 56, 56, 40, 50, 43, 50,
42, 39, 34, 43, 45, 42, 53, 42, 45, 72, 66, 65, 63,
67, 64, 78, 65, 69, 65, 60, 70, 57, 46, 64, 58, 62,
59, 69, 69, 76, 69, 56, 58, 61, 50, 52, 79, 65, 75,
78, 73, 62, 76, 63, 83, 63, 61, 77, 84, 67, 72, 62,
60, 60, 50, 55, 37, 48, 75, 51, 59, 66, 71, 45, 46,
45, 44, 58, 50, 40, 34, 42, 27, 35, 25, 25, 25, 18,
16, 5, 2, 7, 2, 0, 5, 1, 1, 0, 1, 0)
age = 0:99
plot(age, N, type='h', main = "Exposure by Age")
mu = c(0.00246, 0.00064, 0.00026, 0.00014, 0.00014, 0.00059, 0.00031,
0.00016, 0, 0, 0.00034, 0, 0.00018, 0, 0.00016, 0.00047, 0.00015,
0.00013, 0, 0.00023, 0.00021, 2e-04, 1e-04, 0.00021, 0.00053,
0.00073, 0.00021, 0.00085, 0.00033, 0.00033, 0.00045, 0.00079,
0.00034, 0.00045, 0.00077, 0.00066, 0.00077, 0.00099, 0.00074,
0.00096, 0.00127, 0.00099, 0.00103, 7e-04, 0.0022, 0.00177, 0.00263,
0.00247, 0.00171, 0.00189, 0.00408, 0.00297, 0.00326, 0.00285,
0.00402, 0.00441, 0.00584, 0.00485, 0.00475, 0.00484, 0.0074,
0.00782, 0.00777, 0.01002, 0.0108, 0.01277, 0.01026, 0.0135,
0.01316, 0.01467, 0.01353, 0.01839, 0.02011, 0.02176, 0.02507,
0.02801, 0.03008, 0.03849, 0.04071, 0.0516, 0.05487, 0.06088,
0.06675, 0.07599, 0.08657, 0.09597, 0.12556, 0.11733, 0.14262,
0.1601, 0.17928, 0.2002, 0.2229, 0.24739, 0.27361, 0.3015, 0.33094,
0.36176, 0.39377, 0.42671)
plot(age, log(mu), pch=16, main='True Log Mortality Rates by Age\nEstonia 2010')
# trapez approx of life expectancy from a logmx schedule over ages 0..99
e0 = function(logmx) {
mx = exp(logmx)
px = exp(-mx)
lx = c(1,cumprod(px))
return( sum(head(lx,-1) + tail(lx,-1)) / 2)
}
set.seed(6447100)   # change this if you want a different random dataset
D = rpois(100, N*mu)
this.std = c(-5.2232, -7.9576, -8.3774, -8.7403, -8.948, -9.115, -9.028,
-9.2103, -9.2103, -9.4335, -9.4335, -9.2103, -9.115, -8.8049,
-8.6797, -8.6226, -8.3349, -8.1807, -7.9294, -7.824, -7.7994,
-7.6843, -7.6843, -7.6417, -7.5811, -7.4876, -7.4876, -7.4021,
-7.354, -7.2934, -7.2089, -7.1691, -7.0586, -7.0243, -6.9911,
-6.9486, -6.8308, -6.8124, -6.7338, -6.7338, -6.6377, -6.5362,
-6.444, -6.383, -6.2818, -6.2047, -6.1193, -6.0407, -5.9257,
-5.85, -5.7477, -5.6636, -5.5649, -5.4846, -5.4194, -5.3475,
-5.2572, -5.1832, -5.1127, -5.0625, -5.0071, -4.9281, -4.8422,
-4.7689, -4.7094, -4.6356, -4.5497, -4.4542, -4.3788, -4.2723,
-4.1819, -4.0757, -3.966, -3.8859, -3.8126, -3.6977, -3.6071,
-3.4917, -3.4016, -3.2834, -3.1696, -3.0791, -2.9481, -2.8382,
-2.7308, -2.614, -2.5092, -2.371, -2.2583, -2.167, -2.0485, -1.935,
-1.8211, -1.6996, -1.6052, -1.5011, -1.4032, -1.3082, -1.2165,
-1.1282)
fitted_alpha = TOPALS_fit( D, N, this.std)
## single years of age from 0 to max_age
age = 0:max_age
max_age        = 99
knot_positions = c(0,1,10,20,40,70)
smoothing_k    = 1
max_iter       = 20
alpha_tol      = .00005
## single years of age from 0 to max_age
age = 0:max_age
## B is an Ax7 matrix. Each column is a linear B-spline basis function
B      = bs( age, knots=knot_positions, degree=1 )
nalpha = ncol(B)
Q = function(alpha) {
lambda.hat = as.numeric( std + B %*% alpha)
penalty = smoothing_k * sum(diff(alpha)^2)
return( sum(D * lambda.hat - N * exp(lambda.hat)) - penalty)
}
## expected deaths function
Dhat = function(alpha) {
lambda.hat = std + B %*% alpha
return(  as.numeric( N * exp(lambda.hat) ))
}
## S matrix for penalty
S = matrix(0,nalpha-1,nalpha)
diag(S[, 1:(nalpha-1)]) = -1
diag(S[, 2:(nalpha)  ]) = +1
SS = crossprod(S)
SS
next_alpha = function(alpha) {
dhat = Dhat(alpha)
M = solve ( t(B) %*% diag(dhat) %*% B + 2*smoothing_k*SS)
v = t(B) %*% (D - dhat) - 2* (smoothing_k * SS %*% alpha)
return( alpha + M %*% v)
}
a = rep(0, nalpha)
niter = 0
niter      = niter + 1
last_param = a
a          = next_alpha( a )  # update
std = this.std
a = rep(0, nalpha)
niter      = niter + 1
last_param = a
a          = next_alpha( a )  # update
a
change     = a - last_param
change
converge = all( abs(change) < alpha_tol)
converge
overrun  = (niter == max_iter)
overrun
(converge | overrun)
niter      = niter + 1
last_param = a
a          = next_alpha( a )  # update
change     = a - last_param
converge = all( abs(change) < alpha_tol)
overrun  = (niter == max_iter)
a
change
converge
overrun
niter
niter      = niter + 1
last_param = a
a          = next_alpha( a )  # update
change     = a - last_param
converge = all( abs(change) < alpha_tol)
overrun  = (niter == max_iter)
niter
change
converge
overrun
niter      = niter + 1
last_param = a
a          = next_alpha( a )  # update
change     = a - last_param
converge = all( abs(change) < alpha_tol)
overrun  = (niter == max_iter)
change
converge
overrun
(converge | overrun)
TOPALS_fit(D,N,std=this.std)
source('~/GitHub/TOPALS/fit_TOPALS.R', echo=TRUE)
converge
overrun
niter
i=1
repeat { i=i+1;  if (i > 7) {break}}
i
z= function() { repeat { i=i+1;  if (i > 7) {break}} ; print('zz')}
z()
i
z()
source('~/GitHub/TOPALS/fit_TOPALS.R', echo=TRUE)
niter
source('~/GitHub/TOPALS/fit_TOPALS.R', echo=TRUE)
debugSource('~/GitHub/TOPALS/fit_TOPALS.R', echo=TRUE)
change
niter
D
N
last_param
a
debugSource('~/GitHub/TOPALS/fit_TOPALS.R', echo=TRUE)
niter
debugSource('~/GitHub/TOPALS/fit_TOPALS.R', echo=TRUE)
source('~/GitHub/TOPALS/fit_TOPALS.R', echo=TRUE)
smoothing_k
debugSource('~/GitHub/TOPALS/fit_TOPALS.R', echo=TRUE)
niter
last_param
smoothing_k
a
Q(a)
std + B %*% a
alpha
alpha=1
alpha=a
alpha
penalty = smoothing_k * sum(diff(alpha)^2)
penalty
sum(D * lambda.hat - N * exp(lambda.hat)) - penalty
lambda.hat = as.numeric( std + B %*% alpha)
sum(D * lambda.hat - N * exp(lambda.hat)) - penalty
D
D * lambda.hat
N
Dhat(a)
debugSource('~/GitHub/TOPALS/fit_TOPALS.R', echo=TRUE)
a
source('~/GitHub/TOPALS/fit_TOPALS.R', echo=TRUE)
debugSource('~/GitHub/TOPALS/fit_TOPALS.R', echo=TRUE)
a
dhat
M
a
v
\
D - dhat
D
#------------------------------------------------------------
# TOPALS fitting function
#
# Carl Schmertmann
#   created 01 Mar 2018
#   edited  01 Mar 2018
#
# Fits TOPALS parameters to single-year (D,N) data by
# Newton-Raphson iteration with analytical derivatives
#
# A more complete explanation is in
# https://github.com/schmert/TOPALS/blob/master/TOPALS_fitting.pdf
#------------------------------------------------------------
rm(list=ls())
graphics.off()
if (.Platform$OS.type == 'windows') windows(record=TRUE)
library(splines)
TOPALS_fit = function( N, D, std,
max_age        = 99,
knot_positions = c(0,1,10,20,40,70),
smoothing_k    = 1,
max_iter       = 20,
alpha_tol      = .00005,
details        = FALSE) {
## single years of age from 0 to max_age
age = 0:max_age
## B is an Ax7 matrix. Each column is a linear B-spline basis function
B      = bs( age, knots=knot_positions, degree=1 )
nalpha = ncol(B)
## penalized log lik function
Q = function(alpha) {
lambda.hat = as.numeric( std + B %*% alpha)
penalty = smoothing_k * sum(diff(alpha)^2)
return( sum(D * lambda.hat - N * exp(lambda.hat)) - penalty)
}
## expected deaths function
Dhat = function(alpha) {
lambda.hat = std + B %*% alpha
return(  as.numeric( N * exp(lambda.hat) ))
}
## S matrix for penalty
S = matrix(0,nalpha-1,nalpha)
diag(S[, 1:(nalpha-1)]) = -1
diag(S[, 2:(nalpha)  ]) = +1
SS = crossprod(S)
#------------------------------------------------
# iteration function:
# next alpha vector as a function of current alpha
#------------------------------------------------
next_alpha = function(alpha) {
dhat = Dhat(alpha)
M = solve ( t(B) %*% diag(dhat) %*% B + 2*smoothing_k *SS)
v = t(B) %*% (D - dhat) - 2* (smoothing_k * (SS %*% alpha))
return( alpha + M %*% v)
}
## main iteration:
a = rep(0, nalpha)
niter = 0
repeat {
niter      = niter + 1
last_param = a
a          = next_alpha( a )  # update
change     = a - last_param
print(list(niter=niter, data.frame(a=a,change=change)))
converge = all( abs(change) < alpha_tol)
overrun  = (niter == max_iter)
if (converge | overrun) { break }
} # repeat
if (details) {
return( list( alpha    = a,
converge = converge,
maxiter  = overrun))
} else return( alpha)
} # TOPALS_fit
#=====================================================
# EXAMPLE: SMALL POPULATIONS WITH RANDOM DEATHS
#=====================================================
N = c(62, 62, 50, 65, 56, 56, 40, 50, 43, 50,
42, 39, 34, 43, 45, 42, 53, 42, 45, 72, 66, 65, 63,
67, 64, 78, 65, 69, 65, 60, 70, 57, 46, 64, 58, 62,
59, 69, 69, 76, 69, 56, 58, 61, 50, 52, 79, 65, 75,
78, 73, 62, 76, 63, 83, 63, 61, 77, 84, 67, 72, 62,
60, 60, 50, 55, 37, 48, 75, 51, 59, 66, 71, 45, 46,
45, 44, 58, 50, 40, 34, 42, 27, 35, 25, 25, 25, 18,
16, 5, 2, 7, 2, 0, 5, 1, 1, 0, 1, 0)
age = 0:99
plot(age, N, type='h', main = "Exposure by Age")
mu = c(0.00246, 0.00064, 0.00026, 0.00014, 0.00014, 0.00059, 0.00031,
0.00016, 0, 0, 0.00034, 0, 0.00018, 0, 0.00016, 0.00047, 0.00015,
0.00013, 0, 0.00023, 0.00021, 2e-04, 1e-04, 0.00021, 0.00053,
0.00073, 0.00021, 0.00085, 0.00033, 0.00033, 0.00045, 0.00079,
0.00034, 0.00045, 0.00077, 0.00066, 0.00077, 0.00099, 0.00074,
0.00096, 0.00127, 0.00099, 0.00103, 7e-04, 0.0022, 0.00177, 0.00263,
0.00247, 0.00171, 0.00189, 0.00408, 0.00297, 0.00326, 0.00285,
0.00402, 0.00441, 0.00584, 0.00485, 0.00475, 0.00484, 0.0074,
0.00782, 0.00777, 0.01002, 0.0108, 0.01277, 0.01026, 0.0135,
0.01316, 0.01467, 0.01353, 0.01839, 0.02011, 0.02176, 0.02507,
0.02801, 0.03008, 0.03849, 0.04071, 0.0516, 0.05487, 0.06088,
0.06675, 0.07599, 0.08657, 0.09597, 0.12556, 0.11733, 0.14262,
0.1601, 0.17928, 0.2002, 0.2229, 0.24739, 0.27361, 0.3015, 0.33094,
0.36176, 0.39377, 0.42671)
plot(age, log(mu), pch=16, main='True Log Mortality Rates by Age\nEstonia 2010')
# trapez approx of life expectancy from a logmx schedule over ages 0..99
e0 = function(logmx) {
mx = exp(logmx)
px = exp(-mx)
lx = c(1,cumprod(px))
return( sum(head(lx,-1) + tail(lx,-1)) / 2)
}
set.seed(6447100)   # change this if you want a different random dataset
D = rpois(100, N*mu)
this.std = c(-5.2232, -7.9576, -8.3774, -8.7403, -8.948, -9.115, -9.028,
-9.2103, -9.2103, -9.4335, -9.4335, -9.2103, -9.115, -8.8049,
-8.6797, -8.6226, -8.3349, -8.1807, -7.9294, -7.824, -7.7994,
-7.6843, -7.6843, -7.6417, -7.5811, -7.4876, -7.4876, -7.4021,
-7.354, -7.2934, -7.2089, -7.1691, -7.0586, -7.0243, -6.9911,
-6.9486, -6.8308, -6.8124, -6.7338, -6.7338, -6.6377, -6.5362,
-6.444, -6.383, -6.2818, -6.2047, -6.1193, -6.0407, -5.9257,
-5.85, -5.7477, -5.6636, -5.5649, -5.4846, -5.4194, -5.3475,
-5.2572, -5.1832, -5.1127, -5.0625, -5.0071, -4.9281, -4.8422,
-4.7689, -4.7094, -4.6356, -4.5497, -4.4542, -4.3788, -4.2723,
-4.1819, -4.0757, -3.966, -3.8859, -3.8126, -3.6977, -3.6071,
-3.4917, -3.4016, -3.2834, -3.1696, -3.0791, -2.9481, -2.8382,
-2.7308, -2.614, -2.5092, -2.371, -2.2583, -2.167, -2.0485, -1.935,
-1.8211, -1.6996, -1.6052, -1.5011, -1.4032, -1.3082, -1.2165,
-1.1282)
fitted_alpha = TOPALS_fit( N, D, this.std)
#
# fitted.logmx = this.std + B %*% a[,ncol(a)]
#
# plot( age, log(D/N), ylim=c(-10,0), main='TOPALS Fit')
# rug( age[D==0], lwd=2)
# lines(age, this.std, type='l', lty=2, col='grey', lwd=3)
# lines(age, fitted.logmx, lty=1, col='red', lwd=3)
#
debugSource('~/GitHub/TOPALS/fit_TOPALS.R', echo=TRUE)
fitted_alpha
source('~/GitHub/TOPALS/fit_TOPALS.R', echo=TRUE)
fitted_alpha
source('~/GitHub/TOPALS/fit_TOPALS.R', echo=TRUE)
this.e0    = e0(fitted_logmx)
source('~/GitHub/TOPALS/fit_TOPALS.R', echo=TRUE)
rpois( 1000, N*mu)
matrix( rpois( 10*100, N*mu), nrow=100)
rowSums( matrix( rpois( 10*100, N*mu), nrow=100))
plot( age, rowSums( matrix( rpois( 10*100, N*mu), nrow=100)), type='h')
D = matrix( rpois( 100*100, N*mu), nrow=100)
plot( age, rowSums( matrix( rpois( 10*100, N*mu), nrow=100)), type='h')
plot( age, rowSums( D), type='h')
D
dim(D)
D = matrix( rpois( 1000*100, N*mu), nrow=100)
dim(D)
sapply( 1:ncol(D),  function(i) TOPALS_fit(N, D[,i], this.std))
a = sapply( 1:ncol(D),  function(i) TOPALS_fit(N, D[,i], this.std))
dim(a)
B
dim(a)
dim(B)
this.std + B %*% a
matplot( a, this.std + B %*% a, col='lightgrey')
dim( this.std + B %*% a)
matplot( age, this.std + B %*% a, col='lightgrey')
L = this.std + B %*% a
dim(L)
apply(L, 1, quantile, .10)
lines( age, apply(L, 1, quantile, .10), col='black', lty=2)
lines( age, apply(L, 1, quantile, .90), col='black', lty=2)
dim(L)
apply(L, 2, e0)
plot( density( apply(L, 2, e0))
)
abline(v=true_e0)
esim = apply(L, 2, e0)
dim(esim)
which.max(esim)
D[,798]
plot( age, log(D[,798]/N)
)
plot( age, log(D[,798]/N), pch='+', ylim=c(-10,0))
lines(age, L[,798])
e0(L[,798])
quantile(esim, probs=c(10,50,90)/100)
abline(v=quantile(esim, probs=c(10,50,90)/100), col=2)
quantile(esim, probs=c(10,50,90)/100) - true_e0
which.min(esim)
plot( age, log(D[,605]/N), pch='+', ylim=c(-10,0))
lines(age, L[,605])
esim[605]
npop = 1000   # number of populations
# each col of D is a sample of deaths over ages 0..99
D = matrix( rpois( npop*100, N*mu), nrow=100)
# estimate TOPALS parameters for all npop populations in one command
a = sapply( 1:ncol(D), function(i) TOPALS_fit(N, D[,i]))
a = sapply( 1:ncol(D), function(i) TOPALS_fit(N, D[,i], std=this.std))
npop = 1000   # number of populations
# each col of D is a sample of deaths over ages 0..99
D = matrix( rpois( npop*100, N*mu), nrow=100)
# estimate TOPALS parameters for all npop populations in one command
a = sapply( 1:ncol(D), function(i) TOPALS_fit(N, D[,i], std=this.std))
a
system.time ({a = sapply( 1:ncol(D), function(i) TOPALS_fit(N, D[,i], std=this.std))})
npop = 10000   # number of populations
# each col of D is a sample of deaths over ages 0..99
D = matrix( rpois( npop*100, N*mu), nrow=100)
# estimate TOPALS parameters for all npop populations in one command
system.time ({a = sapply( 1:ncol(D), function(i) TOPALS_fit(N, D[,i], std=this.std))})
npop = 1000   # number of populations
# each col of D is a sample of deaths over ages 0..99
D = matrix( rpois( npop*100, N*mu), nrow=100)
# estimate TOPALS parameters for all npop populations in one command
# on a std desktop PC (circa 2014) this <1 sec for 1000 fits
system.time ({a = sapply( 1:ncol(D), function(i) TOPALS_fit(N, D[,i], std=this.std))})
dim(a)
L = this.std + B %*% a   # 100 x npop matrix of fitted logmx schedules
dim(L)
apply(L,1,quantile, c(.10,.50,.90))
Lquant = t( apply(L, 1, quantile, c(.10,.50,.90)) )
Lquant
Lquant = t( apply(L, 1, quantile, c(.10,.50,.90)) )  # 100 x 3
matplot(age, Lquant, lty=c(2,1,2), lwd=c(2,4,2), col=c('red','black','red')
)
matplot(age, Lquant, type='l', lty=c(2,1,2), lwd=c(2,4,2), col=c('red','black','red'))
sel = sample(npop,5)
matlines(age, L[,sel], lty=1, col='lightgrey')
matplot(age, Lquant, type='l', lty=c(2,1,2), lwd=c(2,4,2), col=c('red','black','red'))
sel = sample(npop,5)
matlines(age, L[,sel], lty=1, lwd=2,col='grey')
matplot(age, Lquant, type='l', lty=c(2,1,2), lwd=c(2,4,2), col=c('red','black','red'))
sel = sample(npop,15)
matlines(age, L[,sel], lty=1, lwd=2,col='grey')
# on a std desktop PC (circa 2014) this <1 sec for 1000 fits
system.time ({a = sapply( 1:ncol(D), function(i) TOPALS_fit(N, D[,i], std=this.std))})
L = this.std + B %*% a   # 100 x npop matrix of fitted logmx schedules
Lquant = t( apply(L, 1, quantile, c(.10,.50,.90)) )  # 100 x 3
matplot(age, Lquant, type='l', lty=c(2,1,2), lwd=c(2,4,2), col=c('red','black','red'))
matplot(age, Lquant, type='l', lty=c(2,1,2), lwd=c(2,4,2), col=c('red','black','red'),
main=paste('10,50,90%iles of logmx across',npop,'samples'))
matplot(age, Lquant, type='l', lty=c(2,1,2), lwd=c(2,4,2), col=c('red','black','red'),
main=paste('10,50,90%iles of logmx\nacross',npop,'samples'))
esim = apply(L, 2, e0)
plot(density(esim), main=paste('Density of e0\nacross',npop,'samples'))
equant = quantile(esim, c(.10,.50,.90))
equant
esim = apply(L, 2, e0)
plot(density(esim), main=paste('Density of e0\nacross',npop,'samples'),
lwd=3)
equant = quantile(esim, c(.10,.50,.90))
segments( equant['10%'], 0, equant['90%'], 0, lwd=2)
esim = apply(L, 2, e0)
plot(density(esim), main=paste('Density of e0\nacross',npop,'samples'),
lwd=3)
equant = quantile(esim, c(.10,.50,.90))
segments( equant['10%'], 0, equant['90%'], 0, lwd=2)
points( equant['50%'], 0, pch=16, cex=1.2)
esim = apply(L, 2, e0)
plot(density(esim), main=paste('Density of e0\nacross',npop,'samples'),
lwd=3)
equant = quantile(esim, c(.10,.50,.90))
segments( equant['10%'], 0, equant['90%'], 0, lwd=2)
points( equant['50%'], 0, pch=16, cex=1.2)
abline(v= true_e0, lty=2)
esim = apply(L, 2, e0)
plot(density(esim), main=paste('Density of e0\nacross',npop,'samples'),
lwd=3, bty='l')
equant = quantile(esim, c(.10,.50,.90))
segments( equant['10%'], 0, equant['90%'], 0, lwd=2)
points( equant['50%'], 0, pch=16, cex=1.2)
abline(v= true_e0, lty=2)
esim = apply(L, 2, e0)
plot(density(esim), main=paste('Density of e0\nacross',npop,'samples'),
lwd=3, bty='l', adjust=1.5)
equant = quantile(esim, c(.10,.50,.90))
segments( equant['10%'], 0, equant['90%'], 0, lwd=2)
points( equant['50%'], 0, pch=16, cex=1.2)
abline(v= true_e0, lty=2)
