diag(S[, 2:(nalpha)  ]) = +1
SS = crossprod(S)
#------------------------------------------------
# iteration function:
# next alpha vector as a function of current alpha
#------------------------------------------------
next_alpha = function(alpha) {
dhat = Dhat(alpha)
M = solve ( t(B) %*% diag(dhat) %*% B + 2*smoothing_k *SS)
v = t(B) %*% (D - dhat) - 2* (smoothing_k * (SS %*% alpha))
return( alpha + M %*% v)
}
## main iteration:
a = rep(0, nalpha)
niter = 0
repeat {
niter      = niter + 1
last_param = a
a          = next_alpha( a )  # update
change     = a - last_param
converge = all( abs(change) < alpha_tol)
overrun  = (niter == max_iter)
if (converge | overrun) { break }
} # repeat
if (details | !converge | overrun) {
if (!converge) print('did not converge')
if (overrun) print('exceeded maximum number of iterations')
dhat = Dhat(a)
covar = solve( t(B) %*% diag(dhat) %*% B + 2*smoothing_k *SS)
return( list( alpha    = a,
knots    = knot_positions,
std      = std,
B        = B,
offset   = B %*% a,
logm     = std + B %*% a,
covar    = covar,
Qvalue   = Q(a),
converge = converge,
maxiter  = overrun))
} else return( a)
} # TOPALS_fit
} # if FALSE
N = ITA$expos / 100000
D = ITA$deaths / 100000
## first exploratory iterations
alpha = rep(0,K)
next_alpha = function(alpha) {
eta = as.vector( exp( std + B %*% alpha))
mu  = as.vector( W %*% eta)
Dhat = N * mu
X = W %*% diag(eta) %*% B
A = diag(N/mu)
y = (D-Dhat)/N + X %*% alpha
updated_alpha = solve( t(X) %*% A %*% X, t(X) %*% A %*% y)
return(updated_alpha)
}
maxiter = 10
a = matrix(NA, K, maxiter)
a[,1] = alpha
i = 2
while (i <= maxiter) {
a[,i] = next_alpha( a[,i-1])
delta_a = a[,i] - a[,i-1]
if (all(abs(delta_a) < .00005)) break
i = i+1
}
alpha_hat = a[,i]
## plot data
hues = c('red','darkgreen','royalblue','orangered','salmon','lawngreen')
plot( age+.50, rate1$logmx[1:100], pch=16, ylim=c(-10,0))
lines( age+.50, std, col='grey', lwd=3)
lines( age+.50, std + B %*% alpha_hat, col=sample(hues,1), lwd=3)
for (i in seq(L)) {
y = log(D[i]/N[i])
H = ifelse(i<length(L), L[i+1], 100)
segments(L[i],y,H,y, col='black', lwd=2)
}
abline(v=c(L,100),lty=2, col='grey')
if (FALSE)
{
TOPALS_fit = function( N, D, std,
max_age        = 99,
knot_positions = c(0,1,10,20,40,70),
smoothing_k    = 1,
max_iter       = 20,
alpha_tol      = .00005,
details        = FALSE) {
require(splines)
## single years of age from 0 to max_age
age = 0:max_age
## B is an Ax7 matrix. Each column is a linear B-spline basis function
B      = splines::bs( age, knots=knot_positions, degree=1 )
nalpha = ncol(B)
## penalized log lik function
Q = function(alpha) {
lambda.hat = as.numeric( std + B %*% alpha)
penalty    = smoothing_k * sum( diff(alpha)^2 )
return( sum(D * lambda.hat - N * exp(lambda.hat)) - penalty)
}
## expected deaths function
Dhat = function(alpha) {
lambda.hat = std + B %*% alpha
return(  as.numeric( N * exp(lambda.hat) ))
}
## S matrix for penalty
S = matrix(0,nalpha-1,nalpha)
diag(S[, 1:(nalpha-1)]) = -1
diag(S[, 2:(nalpha)  ]) = +1
SS = crossprod(S)
#------------------------------------------------
# iteration function:
# next alpha vector as a function of current alpha
#------------------------------------------------
next_alpha = function(alpha) {
dhat = Dhat(alpha)
M = solve ( t(B) %*% diag(dhat) %*% B + 2*smoothing_k *SS)
v = t(B) %*% (D - dhat) - 2* (smoothing_k * (SS %*% alpha))
return( alpha + M %*% v)
}
## main iteration:
a = rep(0, nalpha)
niter = 0
repeat {
niter      = niter + 1
last_param = a
a          = next_alpha( a )  # update
change     = a - last_param
converge = all( abs(change) < alpha_tol)
overrun  = (niter == max_iter)
if (converge | overrun) { break }
} # repeat
if (details | !converge | overrun) {
if (!converge) print('did not converge')
if (overrun) print('exceeded maximum number of iterations')
dhat = Dhat(a)
covar = solve( t(B) %*% diag(dhat) %*% B + 2*smoothing_k *SS)
return( list( alpha    = a,
knots    = knot_positions,
std      = std,
B        = B,
offset   = B %*% a,
logm     = std + B %*% a,
covar    = covar,
Qvalue   = Q(a),
converge = converge,
maxiter  = overrun))
} else return( a)
} # TOPALS_fit
} # if FALSE
D
N
N = ITA$expos
D = ITA$deaths
## first exploratory iterations
alpha = rep(0,K)
next_alpha = function(alpha) {
eta = as.vector( exp( std + B %*% alpha))
mu  = as.vector( W %*% eta)
Dhat = N * mu
X = W %*% diag(eta) %*% B
A = diag(N/mu)
y = (D-Dhat)/N + X %*% alpha
updated_alpha = solve( t(X) %*% A %*% X, t(X) %*% A %*% y)
return(updated_alpha)
}
maxiter = 10
a = matrix(NA, K, maxiter)
a[,1] = alpha
i = 2
while (i <= maxiter) {
a[,i] = next_alpha( a[,i-1])
delta_a = a[,i] - a[,i-1]
if (all(abs(delta_a) < .00005)) break
i = i+1
}
alpha_hat = a[,i]
## plot data
hues = c('red','darkgreen','royalblue','orangered','salmon','lawngreen')
plot( age+.50, rate1$logmx[1:100], pch=16, ylim=c(-10,0))
lines( age+.50, std, col='grey', lwd=3)
lines( age+.50, std + B %*% alpha_hat, col=sample(hues,1), lwd=3)
for (i in seq(L)) {
y = log(D[i]/N[i])
H = ifelse(i<length(L), L[i+1], 100)
segments(L[i],y,H,y, col='black', lwd=2)
}
abline(v=c(L,100),lty=2, col='grey')
if (FALSE)
{
TOPALS_fit = function( N, D, std,
max_age        = 99,
knot_positions = c(0,1,10,20,40,70),
smoothing_k    = 1,
max_iter       = 20,
alpha_tol      = .00005,
details        = FALSE) {
require(splines)
## single years of age from 0 to max_age
age = 0:max_age
## B is an Ax7 matrix. Each column is a linear B-spline basis function
B      = splines::bs( age, knots=knot_positions, degree=1 )
nalpha = ncol(B)
## penalized log lik function
Q = function(alpha) {
lambda.hat = as.numeric( std + B %*% alpha)
penalty    = smoothing_k * sum( diff(alpha)^2 )
return( sum(D * lambda.hat - N * exp(lambda.hat)) - penalty)
}
## expected deaths function
Dhat = function(alpha) {
lambda.hat = std + B %*% alpha
return(  as.numeric( N * exp(lambda.hat) ))
}
## S matrix for penalty
S = matrix(0,nalpha-1,nalpha)
diag(S[, 1:(nalpha-1)]) = -1
diag(S[, 2:(nalpha)  ]) = +1
SS = crossprod(S)
#------------------------------------------------
# iteration function:
# next alpha vector as a function of current alpha
#------------------------------------------------
next_alpha = function(alpha) {
dhat = Dhat(alpha)
M = solve ( t(B) %*% diag(dhat) %*% B + 2*smoothing_k *SS)
v = t(B) %*% (D - dhat) - 2* (smoothing_k * (SS %*% alpha))
return( alpha + M %*% v)
}
## main iteration:
a = rep(0, nalpha)
niter = 0
repeat {
niter      = niter + 1
last_param = a
a          = next_alpha( a )  # update
change     = a - last_param
converge = all( abs(change) < alpha_tol)
overrun  = (niter == max_iter)
if (converge | overrun) { break }
} # repeat
if (details | !converge | overrun) {
if (!converge) print('did not converge')
if (overrun) print('exceeded maximum number of iterations')
dhat = Dhat(a)
covar = solve( t(B) %*% diag(dhat) %*% B + 2*smoothing_k *SS)
return( list( alpha    = a,
knots    = knot_positions,
std      = std,
B        = B,
offset   = B %*% a,
logm     = std + B %*% a,
covar    = covar,
Qvalue   = Q(a),
converge = converge,
maxiter  = overrun))
} else return( a)
} # TOPALS_fit
} # if FALSE
alpha_hat
CAN = readHMDweb('CAN', 'fltper_1x1',
password = pw, username=id) %>%
filter(Year==1959, Age<100) %>%
select(age=Age,mx=mx) %>%
mutate(logmx = log(mx))
std = smooth.spline(CAN$logmx, nknots=20)$y
##################################################
age = 0:99
knot_positions = c(0,1,10,20,40,70)
## B is an Ax7 matrix. Each column is a linear B-spline basis function
B      = bs( age, knots=knot_positions, degree=1 )
K = ncol(B)
####################################
L = c(0,1,seq(5,95,5))
W = matrix(0, nrow=length(L), ncol=length(age),
dimnames=list(L,age))
W['0','0'] = 1
W['1',2:5] = 0.25
for (i in 3:21) W[i, 5*(i-2)+1:5] = 0.2
N = ITA$expos
D = ITA$deaths
## first exploratory iterations
alpha = rep(0,K)
next_alpha = function(alpha) {
eta = as.vector( exp( std + B %*% alpha))
mu  = as.vector( W %*% eta)
Dhat = N * mu
X = W %*% diag(eta) %*% B
A = diag(N/mu)
y = (D-Dhat)/N + X %*% alpha
updated_alpha = solve( t(X) %*% A %*% X, t(X) %*% A %*% y)
return(updated_alpha)
}
maxiter = 10
a = matrix(NA, K, maxiter)
a[,1] = alpha
i = 2
while (i <= maxiter) {
a[,i] = next_alpha( a[,i-1])
delta_a = a[,i] - a[,i-1]
if (all(abs(delta_a) < .00005)) break
i = i+1
}
alpha_hat = a[,i]
## plot data
hues = c('red','darkgreen','royalblue','orangered','salmon','lawngreen')
plot( age+.50, rate1$logmx[1:100], pch=16, ylim=c(-10,0))
lines( age+.50, std, col='grey', lwd=3)
lines( age+.50, std + B %*% alpha_hat, col=sample(hues,1), lwd=3)
for (i in seq(L)) {
y = log(D[i]/N[i])
H = ifelse(i<length(L), L[i+1], 100)
segments(L[i],y,H,y, col='black', lwd=2)
}
abline(v=c(L,100),lty=2, col='grey')
if (FALSE)
{
TOPALS_fit = function( N, D, std,
max_age        = 99,
knot_positions = c(0,1,10,20,40,70),
smoothing_k    = 1,
max_iter       = 20,
alpha_tol      = .00005,
details        = FALSE) {
require(splines)
## single years of age from 0 to max_age
age = 0:max_age
## B is an Ax7 matrix. Each column is a linear B-spline basis function
B      = splines::bs( age, knots=knot_positions, degree=1 )
nalpha = ncol(B)
## penalized log lik function
Q = function(alpha) {
lambda.hat = as.numeric( std + B %*% alpha)
penalty    = smoothing_k * sum( diff(alpha)^2 )
return( sum(D * lambda.hat - N * exp(lambda.hat)) - penalty)
}
## expected deaths function
Dhat = function(alpha) {
lambda.hat = std + B %*% alpha
return(  as.numeric( N * exp(lambda.hat) ))
}
## S matrix for penalty
S = matrix(0,nalpha-1,nalpha)
diag(S[, 1:(nalpha-1)]) = -1
diag(S[, 2:(nalpha)  ]) = +1
SS = crossprod(S)
#------------------------------------------------
# iteration function:
# next alpha vector as a function of current alpha
#------------------------------------------------
next_alpha = function(alpha) {
dhat = Dhat(alpha)
M = solve ( t(B) %*% diag(dhat) %*% B + 2*smoothing_k *SS)
v = t(B) %*% (D - dhat) - 2* (smoothing_k * (SS %*% alpha))
return( alpha + M %*% v)
}
## main iteration:
a = rep(0, nalpha)
niter = 0
repeat {
niter      = niter + 1
last_param = a
a          = next_alpha( a )  # update
change     = a - last_param
converge = all( abs(change) < alpha_tol)
overrun  = (niter == max_iter)
if (converge | overrun) { break }
} # repeat
if (details | !converge | overrun) {
if (!converge) print('did not converge')
if (overrun) print('exceeded maximum number of iterations')
dhat = Dhat(a)
covar = solve( t(B) %*% diag(dhat) %*% B + 2*smoothing_k *SS)
return( list( alpha    = a,
knots    = knot_positions,
std      = std,
B        = B,
offset   = B %*% a,
logm     = std + B %*% a,
covar    = covar,
Qvalue   = Q(a),
converge = converge,
maxiter  = overrun))
} else return( a)
} # TOPALS_fit
} # if FALSE
a
CAN = readHMDweb('CAN', 'fltper_1x1',
password = pw, username=id) %>%
filter(Year==1959, Age<100) %>%
select(age=Age,mx=mx) %>%
mutate(logmx = log(mx))
std = smooth.spline(CAN$logmx, nknots=20)$y
##################################################
age = 0:99
knot_positions = c(0,1,10,20,40,70)
## B is an Ax7 matrix. Each column is a linear B-spline basis function
B      = bs( age, knots=knot_positions, degree=1 )
K = ncol(B)
####################################
L = c(0,1,seq(5,95,5))
W = matrix(0, nrow=length(L), ncol=length(age),
dimnames=list(L,age))
W['0','0'] = 1
W['1',2:5] = 0.25
for (i in 3:21) W[i, 5*(i-2)+1:5] = 0.2
N = ITA$expos
D = ITA$deaths
## first exploratory iterations
alpha = rep(0,K)
next_alpha = function(alpha) {
eta = as.vector( exp( std + B %*% alpha))
mu  = as.vector( W %*% eta)
Dhat = N * mu
X = W %*% diag(eta) %*% B
A = diag(N/mu)
y = (D-Dhat)/N + X %*% alpha
updated_alpha = solve( t(X) %*% A %*% X, t(X) %*% A %*% y)
return(updated_alpha)
}
maxiter = 10
a = matrix(NA, K, maxiter)
a[,1] = alpha
i = 2
while (i <= maxiter) {
a[,i] = next_alpha( a[,i-1])
delta_a = a[,i] - a[,i-1]
if (all(abs(delta_a) < .00005)) break
i = i+1
}
alpha_hat = a[,i]
## plot data
hues = c('red','darkgreen','royalblue','orangered','salmon','lawngreen')
plot( age+.50, rate1$logmx[1:100], pch=16, ylim=c(-10,0))
lines( age+.50, std, col='grey', lwd=3)
lines( age+.50, std + B %*% alpha_hat, col=sample(hues,1), lwd=3)
for (i in seq(L)) {
y = log(D[i]/N[i])
H = ifelse(i<length(L), L[i+1], 100)
segments(L[i],y,H,y, col='black', lwd=2)
}
abline(v=c(L,100),lty=2, col='grey')
if (FALSE)
{
TOPALS_fit = function( N, D, std,
max_age        = 99,
knot_positions = c(0,1,10,20,40,70),
smoothing_k    = 1,
max_iter       = 20,
alpha_tol      = .00005,
details        = FALSE) {
require(splines)
## single years of age from 0 to max_age
age = 0:max_age
## B is an Ax7 matrix. Each column is a linear B-spline basis function
B      = splines::bs( age, knots=knot_positions, degree=1 )
nalpha = ncol(B)
## penalized log lik function
Q = function(alpha) {
lambda.hat = as.numeric( std + B %*% alpha)
penalty    = smoothing_k * sum( diff(alpha)^2 )
return( sum(D * lambda.hat - N * exp(lambda.hat)) - penalty)
}
## expected deaths function
Dhat = function(alpha) {
lambda.hat = std + B %*% alpha
return(  as.numeric( N * exp(lambda.hat) ))
}
## S matrix for penalty
S = matrix(0,nalpha-1,nalpha)
diag(S[, 1:(nalpha-1)]) = -1
diag(S[, 2:(nalpha)  ]) = +1
SS = crossprod(S)
#------------------------------------------------
# iteration function:
# next alpha vector as a function of current alpha
#------------------------------------------------
next_alpha = function(alpha) {
dhat = Dhat(alpha)
M = solve ( t(B) %*% diag(dhat) %*% B + 2*smoothing_k *SS)
v = t(B) %*% (D - dhat) - 2* (smoothing_k * (SS %*% alpha))
return( alpha + M %*% v)
}
## main iteration:
a = rep(0, nalpha)
niter = 0
repeat {
niter      = niter + 1
last_param = a
a          = next_alpha( a )  # update
change     = a - last_param
converge = all( abs(change) < alpha_tol)
overrun  = (niter == max_iter)
if (converge | overrun) { break }
} # repeat
if (details | !converge | overrun) {
if (!converge) print('did not converge')
if (overrun) print('exceeded maximum number of iterations')
dhat = Dhat(a)
covar = solve( t(B) %*% diag(dhat) %*% B + 2*smoothing_k *SS)
return( list( alpha    = a,
knots    = knot_positions,
std      = std,
B        = B,
offset   = B %*% a,
logm     = std + B %*% a,
covar    = covar,
Qvalue   = Q(a),
converge = converge,
maxiter  = overrun))
} else return( a)
} # TOPALS_fit
} # if FALSE
